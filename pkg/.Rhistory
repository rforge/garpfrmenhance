b.vec
D.mat
d.vec
?solve.QP
d.vec <- t(mu.bl) * delta
wts.mv = solve.QP(D.mat,d.vec,A.mat,b.vec,meq=1)$solution
wts.mv * 100
wts.mv
wts.mv = round(solve.QP(D.mat,d.vec,A.mat,b.vec,meq=1)$solution,5)
wts.mv * 100
wts.mv
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
setwd("D:/CFRM/Autumn 2014/cfrm 555/week 6/HW 4")
setwd("D:/CFRM/Autumn 2014/cfrm 555/week 6/HW 4")
library(xts)
library(PerformanceAnalytics)
library(quadprog)
library(xlsx)
#Reading the data
dataP<-read.xlsx("Homework4.3 data_P.xlsx", sheetName="Sheet1", header=T)
dataP<-xts(dataP[,2:7],order.by=dataP[,1])
dataV<-read.xlsx("Homework4.3 data_V.xlsx", sheetName="Sheet1", header=T)
dataV<-xts(dataV[,2:7],order.by=dataV[,1])
dataD<-read.xlsx("Homework4.3 data_D.xlsx", sheetName="Sheet1", header=T)
dataD<-xts(dataD[,2:7],order.by=dataD[,1])
dataI<-read.xlsx("Homework4.3 data_I.xlsx", sheetName="Sheet1", header=T)
dataI<-xts(dataI[,2:7],order.by=dataI[,1])
#Giving the dataset as a list
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting teh fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-betas
} else{
wts.list<-rbind(betas.list,betas)
}
}
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
(names(wts.list)<-wts.names)
(wts.list*100)
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting teh fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,betas)
}
}
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting teh fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,wts)
}
}
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
(names(wts.list)<-wts.names)
(wts.list*100)
names(wts.list)
(wts.list*100)
wts.list
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting teh fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,wts)
}
}
wts.names
wts.list
?rownames
(rownames(wts.list)<-wts.names)
(wts.list*100)
wts.list <- round(wts.list,5)
write.csv(wts.csv,"MVWts.csv",sep=",")
write.csv(wts.csv,"MVWts.csv")
write.csv(wts.list,"MVWts.csv")
?require
require(Cholesky)
install.package("Cholesky")
install.package("Cholesky")
install.packages("Cholesky")
require(Cholesky)
Q = rbind(c(16,28,16),c(28,53,18),c(16,18,42))
Cholesky(Q)
require(Matrix)
Q = rbind(c(16,28,16),c(28,53,18),c(16,18,42))
Cholesky(Q)
?Cholesky
Q
class(Q)
Cholesky(Q)
data(KNex)
mtm <- with(KNex, crossprod(mm))
str(mtm@factors) # empty list()
(C1 <- Cholesky(mtm))
C1
Cholesky(Q, LDL=TRUE)
ch <- chol(A)
ch <- chol(Q)
dd <- diag(ch)
dd
ch
L <- t(ch/dd)
DD <- dd^2
DD
L
?QR
?qr
qr(Q)
?chol
ch
ch * t(ch)
Q
ch <- chol(Q)
ch * t(ch)
Q
ch * t(ch)
Q
L*D
L*diag(D)
L
diag(D)
D <- dd^2 ## and diagonal element of D
diag(D)
L*diag(D)
t(L)%*%diag(D)%*%L
(L)%*%diag(D)%*%t(L)
(L)%*%diag(D)%*%t(L)
(L)%*%diag(D)
a%*%b
a<-(L)%*%diag(sqrt(D))
b<-diag(sqrt(D))%*%t(L)
a%*%b
a
b
L <- (ch/dd) ## getting unit lower triangular factor
L
L <- t(ch/dd) ## getting unit lower triangular factor
L
D <- dd^2 ## and diagonal element of D
a<-(L)%*%diag(sqrt(D))
a
diag(sqrt(D)
)
dd
a
a
?chol
D
L <- t(ch/dd) * diag(dd) ## getting unit lower triangular factor
L
L <- t(ch/dd) %*% diag(dd) ## getting unit lower triangular factor
L
U <- t(L)
L%*%U
Q = rbind(c(16,28,16),c(28,53,18),c(16,18,42))
ch <- chol(Q) ## starting from factor given by chol
dd <- diag(ch) ## extract sqrt(D)
L <- t(ch/dd) %*% diag(dd) ## getting unit lower triangular factor
U <- t(L)
L%*%U
Q = rbind(c(16,28,16),c(28,53,18),c(16,18,42))
ch <- chol(Q) ## starting from factor given by chol
dd <- diag(ch) ## extract sqrt(D)
(L <- t(ch/dd) %*% diag(dd)) ## getting unit lower triangular factor
(U <- t(L))
L%*%U
library(xts)
library(PerformanceAnalytics)
library(quadprog)
library(xlsx)
#Reading the data
dataP<-read.xlsx("Homework4.3 data_P.xlsx", sheetName="Sheet1", header=T)
dataP<-xts(dataP[,2:7],order.by=dataP[,1])
dataV<-read.xlsx("Homework4.3 data_V.xlsx", sheetName="Sheet1", header=T)
dataV<-xts(dataV[,2:7],order.by=dataV[,1])
dataD<-read.xlsx("Homework4.3 data_D.xlsx", sheetName="Sheet1", header=T)
dataD<-xts(dataD[,2:7],order.by=dataD[,1])
dataI<-read.xlsx("Homework4.3 data_I.xlsx", sheetName="Sheet1", header=T)
dataI<-xts(dataI[,2:7],order.by=dataI[,1])
#Giving the dataset as a list
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting the fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
#Calculating the parameters for quadprog
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
#Calculating the weights vector
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,wts)
}
}
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
(rownames(wts.list)<-wts.names)
wts.list <- round(wts.list,5)
write.csv(wts.list,"MVWts.csv")
lm(hf.ret~strategies.zoo)
w<-lm(hf.ret~strategies.zoo)
w
w$betas
w$coef
w$coef[-1]
w
w$coef[-1]
library(xts)
library(PerformanceAnalytics)
library(quadprog)
library(xlsx)
#Reading the data
dataP<-read.xlsx("Homework4.3 data_P.xlsx", sheetName="Sheet1", header=T)
dataP<-xts(dataP[,2:7],order.by=dataP[,1])
dataV<-read.xlsx("Homework4.3 data_V.xlsx", sheetName="Sheet1", header=T)
dataV<-xts(dataV[,2:7],order.by=dataV[,1])
dataD<-read.xlsx("Homework4.3 data_D.xlsx", sheetName="Sheet1", header=T)
dataD<-xts(dataD[,2:7],order.by=dataD[,1])
dataI<-read.xlsx("Homework4.3 data_I.xlsx", sheetName="Sheet1", header=T)
dataI<-xts(dataI[,2:7],order.by=dataI[,1])
#Giving the dataset as a list
dataSet<-list(dataP,dataV,dataD,dataI)
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting the fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
#Calculating the parameters for quadprog
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
w<-lm(hf.ret~strategies.zoo)
if(i == 1){
coef<-w$coef
}else {
coef <- rbind(coef,w$coef)
}
#Calculating the weights vector
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,wts)
}
}
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
(rownames(wts.list)<-wts.names)
wts.list <- round(wts.list,5)
write.csv(wts.list,"MVWts.csv")
coef
wts.list
round(coef,5)
strategies.zoo
coef
?lm
install.packages("nnls")
?nnls
??nnls
library(nnls)
w<-nnls(hf.ret~strategies.zoo-1)
w<-nnls(hf.ret,strategies.zoo)
w<-nnls(hf.ret,strategies.zoo)
w<-nnls(strategies.zoo,hf.ret)
w
summary(w)
names(w)
w$fitted
names(w)
w$x
for(i in 1:4)
{
data<-dataSet[[i]]
head(data)
#Getting the fund returns and the indices return
strategies.zoo = data[,1:5]
hf.ret = data[,6]
hf.ret = as.xts(hf.ret)
f = strategies.zoo
r = matrix(hf.ret)
#Calculating the parameters for quadprog
D = t(f) %*% (f)
d = t(f)%*%r
n = length(d[,1])
b = (matrix(c(1,rep(0,n))))
At = diag(n)
At = rbind(rep(1,n),At)
A = t(At)
w<-nnls(strategies.zoo,hf.ret)
if(i == 1){
coef<-w$x
}else {
coef <- rbind(coef,w$x)
}
#Calculating the weights vector
wts = solve.QP(D,d,A,b,1)$solution
names(wts) = names(strategies.zoo)
if(i==1){
wts.list<-wts
} else{
wts.list<-rbind(wts.list,wts)
}
}
wts.names<-c("wts.dataP","wts.dataV","wts.dataD","wts.dataI")
coef
wts.list
data(freetrade)
library(Amelia)
data(freetrade)
amelia(freetrade, m = 1, ts = "year", cs = "country", p2s = 2)
View(freetrade)
summary(freetrade)
parallel::detectCores
parallel::detectCores()
a.out<-amelia(freetrade, m = 1, ts = "year", cs = "country", p2s = 2)
a.out
a.out$imputations$polity
a.out$imputations
a.out1 <- amelia(freetrade, m = 5, ts = "year", cs = "country", ords =
"polity", p2s = 0)
?amelia
a.out1 <- amelia(freetrade, m = 5, ts = "year", cs = "country", ords ="polity", p2s = 0)
a.out1
head(freetrade)
head(freetrade)
amelia(freetrade)
a.out2 <- amelia(freetrade, ts = "year", cs = "country", polytime = 2)
a.out2 <- amelia(freetrade, m = 5, ts = "year", cs = "country", noms =
"signed", p2s = 2)
tscsPlot(a.out, cs = "Malaysia", main = "Malaysia (no time settings)",
var = "tariff", ylim = c(-10, 60))
tscsPlot(a.out.time, cs = "Malaysia", main = "Malaysia (with time settings)",
var = "tariff", ylim = c(-10, 60))
a.out.time <- amelia(freetrade, ts = "year", cs = "country", polytime = 2,
intercs = TRUE, p2s = 2)
a.out<-amelia(freetrade, m = 1, ts = "year", cs = "country", p2s = 2)
tscsPlot(a.out, cs = "Malaysia", main = "Malaysia (no time settings)",
var = "tariff", ylim = c(-10, 60))
tscsPlot(a.out.time, cs = "Malaysia", main = "Malaysia (with time settings)",
var = "tariff", ylim = c(-10, 60))
a.out.time
a.out
a.out$imputation
head(a.out$imputation)
names(a.out$imputation)
a.out$imputation$imp1
head(a.out$imputation$imp1)
a.out
length(a.out)
length(a.out$imputation)
length(a.out$imputation$imp1)
a.out<-amelia(freetrade, m = 5, ts = "year", cs = "country", p2s = 2)
length(a.out$imputation$imp2)
a.out$imputation$imp2
head(a.out$imputation$imp1)
a.out
?write.amelia
setwd("D:/CFRM/Autumn 2014/Research/factor analytics")
write.amelia(a.out, separate = TRUE, "output",
extension = NULL, format = "csv",
impvar = "imp", orig.data = TRUE)
write.amelia(a.out, separate = TRUE, "output.csv",
extension = NULL, format = "csv",
impvar = "imp", orig.data = TRUE)
write.amelia(a.out, "output")
write.amelia(obj=a.out,file.stem= "output")
write.csv(freedtrade,"freetrade.csv")
write.csv(freetrade,"freetrade.csv")
plot(a.out, which.vars = 3:6)
plot(a.out, which.vars = 3:4)
plot(a.out, which.vars = 3:5)
plot(a.out, which.vars = 3:7)
plot(a.out, which.vars = 3:8)
plot(a.out, which.vars = 3:9)
plot(a.out, which.vars = 3:10)
plot(a.out, which.vars = 3:13)
plot(a.out, which.vars = 2:6)
plot(a.out, which.vars = 2:5)
plot(a.out, which.vars = 2:7)
plot(a.out, which.vars = 2:9)
plot(a.out, which.vars = 2:11)
compare.density(a.out, var = "signed")
compare.density(a.out, var = "signed")
compare.density(a.out, var = "signed")
compare.density(a.out, var = "signed")
compare.density(a.out, var = "signed")
compare.density(a.out, var = "signed")
compare.density(a.out, var = "tarrif")
head(freetrade)
compare.density(a.out, var = "tariff")
?mi.meld
?meld
ameilaView()
AmeliaView()
install.packages("VIM")
data(sleep, package="VIM")
library(sleep)
library(sleep)
library(VIM)
data(sleep, package="VIM")
a <- aggr(sleep)
a
summary(a)
a
head(sleep)
shiny::runApp('D:/CFRM/Summer 2014/GARPFRM/FixedIncome')
shiny::runApp('D:/CFRM/Summer 2014/GARPFRM/FixedIncome')
shinyApps::deployApp()
shinyapps::deployApp()
shiny::runApp('D:/CFRM/Summer 2014/GARPFRM/FixedIncome')
setwd("D:/CFRM/Summer 2014/GARPFRM/FixedIncome")
shinyapps::deployApp()
shiny::runApp('D:/CFRM/Summer 2014/GARPFRM/capm code')
shiny::runApp('D:/CFRM/Summer 2014/GARPFRM/FixedIncome')
shiny::runApp()
